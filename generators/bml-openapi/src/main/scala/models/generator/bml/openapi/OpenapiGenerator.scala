package models.generator.bml.openapi

import java.util

import bml.util.java.JavaPojoUtil
import bml.util.openapi.Info.License
import bml.util.openapi.{Components, Info, Items, OpenApi, Property, Ref, Schema, Type}
import bml.util.{NameSpaces, SpecValidation}
import com.fasterxml.jackson.databind.{ObjectMapper, SerializationFeature}
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import io.apibuilder.generator.v0.models.{File, InvocationForm}
import io.apibuilder.spec.v0.models.{Operation, ResponseCodeInt, Service}
import lib.generator.CodeGenerator
import play.api.Logger

import scala.collection.mutable
import lib.Text._


/**
 * Geenerates an OpenApi v3.0.0 file from a specification.
 *
 * Validates against swagger-cli v3.0.1.
 *
 */
class OpenapiGenerator extends CodeGenerator {

  import collection.JavaConverters._

  val logger: Logger = Logger.apply(this.getClass())

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN Common generator invocation
  override def invoke(form: InvocationForm): Either[Seq[String], Seq[File]] = invoke(form, addHeader = true)

  def invoke(form: InvocationForm, addHeader: Boolean = false): Either[Seq[String], Seq[File]] = generateCode(form, addHeader)

  private def generateCode(form: InvocationForm, addHeader: Boolean = true): Either[Seq[String], Seq[File]] = {
    val header =
      if (addHeader) Some(new ApidocComments(form.service.version, form.userAgent).forClassFile)
      else None
    logger.info(s"Processing Application ${form.service.name}")
    // ENSURE Spec before even creating the generator
    val errors = SpecValidation.validate(form.service, header)
    if (errors.isDefined) {
      return Left(errors.get)
    }
    //Spec passed
    new Generator(form.service, header).generateSourceFiles()
  }

  // END Common generator invocation
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Generates an openapi 3.0.0 file from a specification.
   *
   * @param service the service specification
   * @param header  optional header to add to the top of each generated file
   */
  class Generator(service: Service, header: Option[String]) {
    private val nameSpaces = new NameSpaces(service)

    def generateSourceFiles(): Either[Seq[String], Seq[File]] = {
      Right(generate())
    }

    /**
     * Turns a type into a $ref. Handles external files as long as they are generated by this generator.
     *
     * @param service the api Service object
     * @param typeIn  the type string
     * @return a $ref value
     */
    def toRef(service: Service, typeIn: String): String = {
      //Handle model names with packages
      if (JavaPojoUtil.isModelNameWithPackage(typeIn)) {
        val modelName = typeIn
        val fileName = typeIn.split("\\.").drop(2).dropRight(3).map(_.capitalize).mkString("") + ".yaml"
        return s"${fileName}#/components/schemas/${modelName}"
      }
      //handle file local $refs
      s"#/components/schemas/${nameSpaces.model.nameSpace}.${typeIn}"
    }

    def generate(): Seq[File] = {
      val schemas = service.models.map(
        modelIn => {
          val schemaOut = Schema.builder().description(modelIn.description.getOrElse(null))
          modelIn.fields.foreach(
            fieldIn => {
              val propertyOut = Property.builder()
              if (fieldIn.description.isDefined) propertyOut.description(fieldIn.description.get)
              if (JavaPojoUtil.isModelNameWithPackage(fieldIn.`type`)) {
                propertyOut.oneOf(Ref.builder().ref(fieldIn.`type`).build())
              } else if (JavaPojoUtil.isModelType(service, fieldIn)) {
                propertyOut.oneOf(Ref.builder().ref(toRef(service, fieldIn.`type`)).build())
              } else if (fieldIn.`type`.startsWith("[") && fieldIn.`type`.endsWith("]")) {
                propertyOut.`type`("array")
                val itemType = fieldIn.`type`.toCharArray.drop(1).dropRight(1).mkString("")
                propertyOut.items(Items.builder().ref(toRef(service, itemType)).build())
              } else {
                propertyOut.`type`(Type.`object`.name())
                if (fieldIn.`type` == "uuid") {
                  propertyOut.format("uuid")
                } else if (fieldIn.`type` == "date-iso8601")
                  propertyOut.`type`("string")
                    .format("date-time")
              }
              schemaOut.property(fieldIn.name, propertyOut.build())
            }
          )
          nameSpaces.model.nameSpace + "." + modelIn.name -> schemaOut.build()
        }
      ).toMap ++ service.enums.map(
        enumIn => {
          val schemaOut = Schema.builder().description(enumIn.description.getOrElse(null))
          schemaOut.`type`(Type.string)
          schemaOut.enums(
            enumIn.values.map(_.name).asJava
          )
          nameSpaces.model.nameSpace + "." + enumIn.name -> schemaOut.build()
        }
      )

      val components = Components.builder().schemas(schemas.asJava).build()

      def toOperationId(operation: Operation): String = {
        s"${operation.method.toString.toLowerCase()}-${operation.path.replace("/", "-")}"
      }

      val paths = new mutable.LinkedHashMap[String, Object].asJava
      service.resources.foreach(
        resourceIn => {
          resourceIn.operations.foreach(
            operationIn => {
              val DESCRIPTION = "description"
              val pathOut = new mutable.LinkedHashMap[String, Object].asJava
              val operationOut = new mutable.LinkedHashMap[String, Object].asJava
              pathOut.put(operationIn.method.toString.toLowerCase(), operationOut)
              operationOut.put(DESCRIPTION, operationIn.description.getOrElse(null))
              operationOut.put("operationId", toOperationId(operationIn))
              val parameters = new util.LinkedList[Map[String, Object]]()
              operationOut.put("parameters", parameters)
              val responsesOut = new mutable.LinkedHashMap[String, Object].asJava
              operationOut.put("responses", responsesOut)

              //Do response codes
              operationIn.responses.foreach(
                responseIn => {
                  val responseOut = mutable.LinkedHashMap[String, Object]().asJava
                  if (responseIn.description.isDefined) {
                    responseOut.put(DESCRIPTION, responseIn.description.get)
                  }
                  if (responseIn.`type` == "unit") {

                  } else if (JavaPojoUtil.isModelNameWithPackage(responseIn.`type`) || JavaPojoUtil.isModelType(service, responseIn.`type`)) {
                    val contentOut = new mutable.LinkedHashMap[String, Object].asJava
                    val contentTypeOut = new mutable.LinkedHashMap[String, Object].asJava
                    contentOut.put("application/json", contentTypeOut)
                    val schemaOut = new mutable.LinkedHashMap[String, Object].asJava
                    schemaOut.put("$ref", toRef(service, responseIn.`type`))
                    contentTypeOut.put("schema", schemaOut)
                    responseOut.put("content", contentOut)
                  }
                  responsesOut.put(responseIn.code.asInstanceOf[ResponseCodeInt].value.toString, responseOut)
                }
              )

              paths.put(operationIn.path, pathOut)
            }
          )
        }
      )

      val openapi = OpenApi.builder().components(components)
        .paths(paths)
      openapi.info(
        Info.builder()
          .contact(Info.Contact.builder().build())
          .license(License.builder().name("").build())
          .termsOfService("foo.com")
          .title(service.name)
          .version(service.version)
          .build()
      )
      val mapper = new ObjectMapper(new YAMLFactory()).disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)


      val name = JavaPojoUtil.toClassName(service.name);
      Seq(
        File(name = s"${name}.yaml", contents = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(openapi.build()))
      )
    }
  }


}
