package models.generator.bml.openapi

import java.util
import java.util.concurrent.atomic.LongAdder

import akka.http.scaladsl.model.headers.LinkParams
import akka.http.scaladsl.model.headers.LinkParams.`type`
import bml.util.attribute.{OpenAPISecuritySchemes, Servers, Tags}
import bml.util.java.JavaPojoUtil
import bml.util.java.JavaPojoUtil.isModelType
import bml.util.java.JavaPojoUtil.isEnumType
import bml.util.java.JavaPojoUtil.isModelNameWithPackage
import bml.util.java.JavaPojoUtil.islistOfModelNameWithPackage
import bml.util.java.JavaPojoUtil.isParameterArray
import bml.util.java.JavaPojoUtil.isListOfModeslType
import bml.util.java.JavaPojoUtil.isListOfEnumlType
import bml.util.openapi.model.{Components, In, Info, Items, OpenApi, ParamSchema, Parameter, Property, Ref, Schema, Server, Tag, Type}
import bml.util.openapi.model.Info.License
import bml.util.{NameSpaces, SpecValidation}
import com.fasterxml.jackson.databind.{ObjectMapper, SerializationFeature}
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import io.apibuilder.generator.v0.models.{File, InvocationForm}
import io.apibuilder.spec.v0.models.{Field, Operation, ParameterLocation, ResponseCodeInt, Service}
import lib.generator.CodeGenerator
import play.api.Logger

import scala.collection.mutable
import lib.Text._


/**
 * Geenerates an OpenApi v3.0.0 file from a specification.
 * Includes extenral schemas using file names and Ref.
 *
 * Validates against swagger-cli v3.0.1.
 *
 */
class OpenapiGenerator extends CodeGenerator {

  //We are using jackson here so we need to convert scala collections to java collections pre-render.

  import collection.JavaConverters._

  /**
   * Standard logger
   */
  val logger: Logger = Logger.apply(this.getClass())

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN Common generator invocation
  override def invoke(form: InvocationForm): Either[Seq[String], Seq[File]] = invoke(form, addHeader = true)

  def invoke(form: InvocationForm, addHeader: Boolean = false): Either[Seq[String], Seq[File]] = generateCode(form, addHeader)

  private def generateCode(form: InvocationForm, addHeader: Boolean = true): Either[Seq[String], Seq[File]] = {
    val header =
      if (addHeader) Some(new ApidocComments(form.service.version, form.userAgent).forClassFile)
      else None
    logger.info(s"Processing Application ${form.service.name}")
    // ENSURE Spec before even creating the generator
    val errors = SpecValidation.validate(form.service, header)
    if (errors.isDefined) {
      return Left(errors.get)
    }
    //Spec passed
    new Generator(form.service, header).generateSourceFiles()
  }

  // END Common generator invocation
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Generates an openapi 3.0.0 file from a specification.
   *
   * @param service the service specification
   * @param header  optional header to add to the top of each generated file
   */
  class Generator(service: Service, header: Option[String]) {
    private val nameSpaces = new NameSpaces(service)

    def generateSourceFiles(): Either[Seq[String], Seq[File]] = {
      Right(generate())
    }

    /**
     * Turns a type into a $ref. Handles external files as long as they are generated by this generator.
     *
     * @param typeIn the type string
     * @return a $ref value
     */
    def toRef(typeIn: String): String = {
      //Handle model names with packages
      if (isModelNameWithPackage(typeIn)) {
        val modelName = toModelName(JavaPojoUtil.replaceEnumsPrefixWithModels(typeIn))
        val fileName = typeIn.split("\\.").drop(2).dropRight(3).map(_.capitalize).mkString("") + ".yml"
        return s"${fileName}#/components/schemas/${modelName}"
      }
      s"#/components/schemas/${nameSpaces.model.nameSpace}.${typeIn.capitalize}"
    }

    val DESCRIPTION = "description"


    /**
     * Enum descriptions are not part of the openapi spec (ameture hour). So we add in some basic HTML into the
     * description string and hope doc tools show it apropriately. This is a major shortcomming of openapi.
     *
     * @param enum the enum to document
     * @return a description string with all the enum value descriptions.
     */
    def enumToDescription(enum: io.apibuilder.spec.v0.models.Enum): String = {
      var out = Seq[String]()
      if (`enum`.deprecation.isDefined) {
        var depreciaion = `enum`.deprecation.get
        if (depreciaion.description.isDefined) {
          out = out ++ Seq(s"@Depreciated ${depreciaion.description.get}")
        } else {
          out = out ++ Seq("@Depreciated")
        }
      }
      if (`enum`.description.isDefined) {
        out = out ++ Seq(`enum`.description.get)
      }
      // assemble descriptions for each enum value
      out = out ++ Seq("<ol>") ++ `enum`.values.map(valueIn => {
        valueIn.value.getOrElse(valueIn.name) -> (
          if (valueIn.description.isDefined) {
            valueIn.description.get
          } else {
            ""
          }
          )
      }).map(t => s"<b>${t._1}</b> ${t._2}").map(s => s"<li>${s}</li>") ++ Seq("</ol>")

      out.mkString("<br> ")
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //BEGIN Mapping of primitive types from apibuilder json to openapi primitives
    def isPrimitive(typeIn: String): Boolean = {
      typeIn match {
        case "uuid" => true
        case "string" => true
        case "integer" => true
        case "date-iso8601" => true
        case default => false
      }
    }

    def toPrimitive(typeIn: String): Option[String] = {
      typeIn match {
        case "uuid" => Some("string")
        case "string" => Some("string")
        case "integer" => Some("integer")
        case "date-iso8601" => Some("string")
        case default => None
      }
    }

    /**
     * Tells if a primitive data type has an accompanying format.
     *
     * @param typeIn a type
     * @return true if the data type has a format false otherwise
     */
    def hasFormat(typeIn: String): Boolean = {
      typeIn match {
        case "uuid" => true
        case "date-iso8601" => true
        case default => false
      }
    }

    /**
     * Returns an openapi format optional if one exists for the type passed.
     *
     * @param typeIn a type
     * @return some format or none if one does not exist
     */
    def getFormat(typeIn: String): Option[String] = {
      typeIn match {
        case "uuid" => Some("uuid")
        case "date-iso8601" => Some("date-time")
        case default => None
      }
    }

    //END Mapping of primitive types from apibuilder json to openapi primitives
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    def toModelName(typeName: String): String = {
      if (isModelNameWithPackage(typeName) || isModelType(service, typeName)) {
        val ary = typeName.split('.')
        ary.updated(ary.size - 1, ary.last.capitalize).mkString(".")
      } else {
        typeName
      }
    }

    def generate(): Seq[File] = {
      val schemas = service.models.map(
        modelIn => {
          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
          // START OPENAPI SCHEMA
          val schemaOut = Schema.builder().description(modelIn.description.getOrElse(null))

          modelIn.fields.foreach(
            fieldIn => {
              if (fieldIn.required) {
                schemaOut.requiredField(toModelName(fieldIn.name))
              }
            }
          )







          //For all model Fields
          modelIn.fields.foreach(
            fieldIn => {
              //              if (fieldIn.name == "errors") {
              //                logger.warn(s"Processing serivce=${service.name} model=${modelIn.name} field=${fieldIn.name}")
              //              }

              //Get builder
              val propertyOut = Property.builder()

              //Set Description
              if (fieldIn.description.isDefined) {
                propertyOut
                  .description(fieldIn.description.get)
              }

              //Adds a list of models to the property
              def addArrayType(): Unit = {
                propertyOut
                  .`type`(Type.array.name())
                  .items(
                    Items.builder()
                      .ref(
                        toRef(JavaPojoUtil.getArrayType(fieldIn))
                      ).build())
              }


              if (isModelType(service, fieldIn) || isEnumType(service, fieldIn)) {
                //IS Local model
                propertyOut
                  .oneOf(
                    Ref.builder()
                      .ref(toRef(fieldIn.`type`))
                      .build())
                //Add OneOf if we are a local model
              } else if (isListOfModeslType(service, fieldIn) || isListOfEnumlType(service, fieldIn)) {
                //I am a list of models or enums
                addArrayType()
              } else if (islistOfModelNameWithPackage(fieldIn.`type`)) {
                //I am a list of models
                addArrayType()
              }
              else if (isModelNameWithPackage(fieldIn.`type`)) {
                //Is remote model
                if (JavaPojoUtil.isListOfModeslType(service, fieldIn)) {
                  //I am a list of models
                  addArrayType()
                } else {
                  propertyOut
                    .oneOf(Ref.builder().ref(fieldIn.`type`).build())
                }

              } else if (JavaPojoUtil.isParameterArray(fieldIn)) {
                //Is array
                logger.info(s"Property Type ='${fieldIn.`type`}'")
                addArrayType()
              } else {
                val typeIn = fieldIn.`type`
                if (isPrimitive(typeIn)) {
                  val typeOut = toPrimitive(typeIn)
                  if (typeOut.isDefined) {
                    propertyOut.`type`(typeOut.get)
                  }
                  if (fieldIn.minimum.isDefined) {
                    propertyOut.minLength(fieldIn.minimum.get)
                  }
                  if (fieldIn.maximum.isDefined) {
                    propertyOut.maxLength(fieldIn.maximum.get)
                  }
                  if (hasFormat(typeIn)) {
                    val formatOut = getFormat(typeIn)
                    if (formatOut.isDefined) {
                      propertyOut.format(formatOut.get)
                    }
                  }
                }
              }
              schemaOut.property(fieldIn.name, propertyOut.build())
            }
          )
          nameSpaces.model.nameSpace + "." + modelIn.name.capitalize -> schemaOut.build()
        }

      ).toMap ++ service.enums.map(
        enumIn => {
          val schemaOut = Schema.builder().description(enumToDescription(enumIn))
          schemaOut.`type`(Type.string)
          schemaOut.enums(

            enumIn.values.map(
              e => e.value.getOrElse(e.name)
            ).asJava
            //            enumIn.values.map(_.name).asJava
          )
          nameSpaces.model.nameSpace + "." + enumIn.name.capitalize -> schemaOut.build()
        }
      )

      val components = Components.builder().schemas(schemas.asJava)

      //      service.attributes.filter(OpenAPISecuritySchemes.isThisAttribute(_))
      //        .map(OpenAPISecuritySchemes.asThisAttribute(_))
      //        .filter(_.isDefined)
      //        .map(_.get)
      //        .foreach(
      //          attributeIn => {
      //            val operationOut = new mutable.LinkedHashMap[String, Object].asJava
      //            operationOut.put("type", attributeIn.`type`)
      //            components.securityScheme(attributeIn.name, operationOut)
      //          }
      //        )

      def toOperationId(operation: Operation): String = {
        s"${operation.method.toString.toLowerCase()}-${operation.path.replace("/", "-")}"
      }

      def isAnyModelType(typeIn: String): Boolean = {
        (JavaPojoUtil.isModelType(service, typeIn)
          ||
          JavaPojoUtil.isModelNameWithPackage(typeIn)
          )
      }

      val paths = new mutable.LinkedHashMap[String, util.LinkedHashMap[String, Object]].asJava
      service.resources.foreach(
        resourceIn => {
          resourceIn.operations.foreach(
            operationIn => {

              val method = operationIn.method.toString.toLowerCase()

              val operationOut = new mutable.LinkedHashMap[String, Object].asJava

              if (operationIn.description.isDefined) {
                operationOut.put(DESCRIPTION, operationIn.description.get)
              }

              operationOut.put("operationId", toOperationId(operationIn))
              //////////////////////////////////////////////////////////////////////////////////////////////////////////
              //////////////////////////////////////////////////////////////////////////////////////////////////////////
              // BEGIN Post Request body
              if (method == "post" || method == "put") {
                if (operationIn.body.isDefined) {
                  val bodyIn = operationIn.body.get
                  val requestBody = new mutable.LinkedHashMap[String, Object].asJava
                  operationIn.body.get.description
                  if (bodyIn.description.isDefined) {
                    requestBody.put("description", bodyIn.description.get)
                  }
                  requestBody.put("required", java.lang.Boolean.TRUE)

                  val content = new mutable.LinkedHashMap[String, Object].asJava

                  val applicationJson = new mutable.LinkedHashMap[String, Object].asJava
                  content.put("application/json", applicationJson)

                  if (isListOfModeslType(service, bodyIn.`type`)) {

                    val schema = new mutable.LinkedHashMap[String, Object].asJava
                    schema.put("type", Type.array)
                    schema.put("items", Items.builder().ref(toRef(JavaPojoUtil.getArrayType(bodyIn.`type`))).build())
                    applicationJson.put("schema", schema)
                  }

                  if (isModelType(service, bodyIn.`type`)) {
                    val schemaOut = new mutable.LinkedHashMap[String, Object].asJava
                    schemaOut.put("$ref", toRef(bodyIn.`type`))
                    applicationJson.put("schema", schemaOut)
                  }


                  requestBody.put("content", content)


                  operationOut.put("requestBody", requestBody)

                }
              }
              // END Post Request body
              //////////////////////////////////////////////////////////////////////////////////////////////////////////
              //////////////////////////////////////////////////////////////////////////////////////////////////////////


              val parameters = new util.LinkedList[Parameter]()
              operationOut.put("parameters", parameters)
              val responsesOut = new mutable.LinkedHashMap[String, Object].asJava
              operationOut.put("responses", responsesOut)






              //Do response codes
              operationIn.responses.foreach(
                responseIn => {
                  val responseOut = mutable.LinkedHashMap[String, Object]().asJava
                  if (responseIn.description.isDefined) {
                    responseOut.put(DESCRIPTION, responseIn.description.get)
                  }
                  if (responseIn.`type` == "unit") {

                  } else if (isAnyModelType(responseIn.`type`)) {
                    val contentOut = new mutable.LinkedHashMap[String, Object].asJava
                    val contentTypeOut = new mutable.LinkedHashMap[String, Object].asJava
                    contentOut.put("application/json", contentTypeOut)
                    val schemaOut = new mutable.LinkedHashMap[String, Object].asJava
                    schemaOut.put("$ref", toRef(responseIn.`type`))
                    contentTypeOut.put("schema", schemaOut)
                    responseOut.put("content", contentOut)
                  }
                  else if (JavaPojoUtil.isListOfModeslType(service, responseIn.`type`)) {
                    //                    val contentOut = new mutable.LinkedHashMap[String, Object].asJava
                    //                    val contentTypeOut = new mutable.LinkedHashMap[String, Object].asJava
                    //                    contentOut.put("application/json", contentTypeOut)
                    //                    val schemaOut = new mutable.LinkedHashMap[String, Object].asJava
                    //                    val oneOfOut = new mutable.LinkedHashMap[String, Object].asJava
                    //
                    //                    oneOfOut.put("$ref", toRef(JavaPojoUtil.getArrayType(responseIn.`type`)))
                    //                    schemaOut.put("type", "array")
                    //                    schemaOut.put("items", oneOfOut)
                    //                    contentTypeOut.put("schema", schemaOut)
                    //                    responseOut.put("content", contentOut)

                  }

                  responsesOut.put(responseIn.code.asInstanceOf[ResponseCodeInt].value.toString, responseOut)
                }
              )


              def toParamSchema(typeIn: String): ParamSchema = {
                val paramSchemaOut = ParamSchema.builder()


                def buildRef(): Ref = {
                  Ref.builder()
                    .ref(
                      toRef(typeIn))
                    .build()

                }
                //If Model with package
                if (isModelNameWithPackage(typeIn)) {
                  paramSchemaOut.ref(toRef(typeIn))
                  //                  paramSchemaOut.oneOf(buildRef())
                  //If Model
                } else if (JavaPojoUtil.isEnumType(service, typeIn)) {
                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  // BEGIN ref to enumeration type in operation param
                  //                  paramSchemaOut.oneOf(buildRef())
                  //paramSchemaOut.(buildRef())
                  paramSchemaOut.ref(toRef(typeIn))

                  // END ref to enumeration type in operation param
                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  //////////////////////////////////////////////////////////////////////////////////////////////////////


                  //If Parameter array
                } else if (isModelType(service, typeIn)) {
                  //                  paramSchemaOut.oneOf(buildRef())
                  paramSchemaOut.ref(toRef(typeIn))
                  //If Parameter array
                } else if (JavaPojoUtil.isParameterArray(typeIn)) {
                  logger.info(s"PARAMETER TYPE ${typeIn}")
                  paramSchemaOut.`type`(Type.array.name())
                  //                  val itemType = typeIn.toCharArray.drop(1).dropRight(1).mkString("")
                  val itemType = JavaPojoUtil.getArrayType(typeIn)

                  if (itemType.equals("uuid")) {
                    logger.info(s"PARAMETER TYPE ${itemType}")
                    paramSchemaOut.items(
                      Items.builder()
                        .`type`(itemType)
                        .build()
                    )

                  } else {
                    paramSchemaOut.items(
                      Items.builder()
                        .ref(toRef(itemType))
                        .build()
                    )
                  }


                } else {

                  //val typeIn = fieldIn.`type`
                  if (isPrimitive(typeIn)) {
                    val typeOut = toPrimitive(typeIn)
                    if (typeOut.isDefined) {
                      paramSchemaOut.`type`(typeOut.get)
                    }
                    if (hasFormat(typeIn)) {
                      val formatOut = getFormat(typeIn)
                      if (formatOut.isDefined) {
                        paramSchemaOut.format(formatOut.get)
                      }
                    }
                  }
                }


                paramSchemaOut.build()

              }
              ////////////////////////////////////////////////////////////////////////////////////////////////////////
              ////////////////////////////////////////////////////////////////////////////////////////////////////////


              operationIn.parameters.foreach(
                parameterIn => {
                  val parameterOut = Parameter.builder()
                    .name(parameterIn.name)
                  if (parameterIn.deprecation.isDefined) {
                    parameterOut.deprecated(true)
                  }


                  if (parameterIn.description.isDefined) {
                    parameterOut.description(parameterIn.description.get)
                  }

                  parameterOut.required(
                    if (parameterIn.default.isDefined) {
                      false
                    } else {
                      parameterIn.required
                    }
                  )
                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  // Handle defaults
                  if (parameterIn.default.isDefined) {
                    parameterOut.defaultValue(parameterIn.default.get)
                  }
                  //////////////////////////////////////////////////////////////////////////////////////////////////////

                  if (parameterIn.location.equals(ParameterLocation.Header))
                    parameterOut.in(In.header)
                  if (parameterIn.location.equals(ParameterLocation.Path))
                    parameterOut.in(In.path)

                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  //Make sure this converts

                  parameterOut.schema(
                    toParamSchema(parameterIn.`type`)
                  )
                  //////////////////////////////////////////////////////////////////////////////////////////////////////

                  parameters.add(parameterOut.build())
                }
              )


              def toPath(operation: Operation): String = {
                "/v" + service.version.split("\\.").head +
                  operation.path.split('/').map(
                    pathElement =>
                      if (pathElement.startsWith(":")) {
                        "{" + pathElement.stripPrefix(":") + "}"
                      } else {
                        pathElement
                      }
                  ).mkString("/")
              }


              val pathOut = new mutable.LinkedHashMap[String, Object].asJava
              pathOut.put(operationIn.method.toString.toLowerCase(), operationOut)

              val adderSupplier = new java.util.function.Function[String, util.LinkedHashMap[String, Object]]() {
                override def apply(t: String): util.LinkedHashMap[String, Object] = new util.LinkedHashMap[String, Object]
              }

              paths.computeIfAbsent(toPath(operationIn), adderSupplier).put(operationIn.method.toString.toLowerCase(), operationOut)

              //              paths.put(toPath(operationIn), pathOut)
            }

          )
        }

      )

      val openapi = OpenApi.builder().components(components.build())
        .paths(paths)

      //Handle top level tags
      val tags = Tags.fromAttributes(service.attributes)
      if (tags.isDefined) {
        tags.get.tags.foreach(
          tagName =>
            openapi.tag(Tag.builder().name(tagName).build())
        )
      }
      //Handle top level servers
      val servers = Servers.fromAttributes(service.attributes)
      if (servers.isDefined) {
        servers.get.uris.foreach(uri => {
          openapi.server(
            Server.builder().url(uri).build()
          )
        }
        )
      } else {
        openapi.server(
          Server.builder().url("/").build()
        )
      }


      val openAPISecuritySchemes = OpenAPISecuritySchemes.fromAttributes(service.attributes);


      openapi.info(
        Info.builder()
          .title(service.name)
          .contact(Info.Contact.builder().build())
          .license(License.builder().name("").build())
          .termsOfService("foo.com")
          .title(service.name)
          .version(service.version)
          .build()
      )
      val mapper = new ObjectMapper(new YAMLFactory()).disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)
      //      val mapper = new ObjectMapper().disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)


      val name = JavaPojoUtil.toClassName(service.name);
      Seq(
        File(name = s"${name}.yml", contents = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(openapi.build()))
      )
    }

  }


}
