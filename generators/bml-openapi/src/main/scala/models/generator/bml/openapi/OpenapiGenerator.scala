package models.generator.bml.openapi

import java.util

import bml.util.attribute.OpenAPISecuritySchemes
import bml.util.java.JavaPojoUtil
import bml.util.java.JavaPojoUtil.isModelType
import bml.util.java.JavaPojoUtil.isModelNameWithPackage

import bml.util.openapi.Info.License
import bml.util.openapi.{Components, Info, Items, OpenApi, ParamSchema, Parameter, Property, Ref, Schema, Type}
import bml.util.{NameSpaces, SpecValidation}
import com.fasterxml.jackson.databind.{ObjectMapper, SerializationFeature}
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import io.apibuilder.generator.v0.models.{File, InvocationForm}
import io.apibuilder.spec.v0.models.{Operation, ResponseCodeInt, Service}
import lib.generator.CodeGenerator
import play.api.Logger

import scala.collection.mutable
import lib.Text._


/**
 * Geenerates an OpenApi v3.0.0 file from a specification.
 *
 * Validates against swagger-cli v3.0.1.
 *
 */
class OpenapiGenerator extends CodeGenerator {

  import collection.JavaConverters._

  val logger: Logger = Logger.apply(this.getClass())

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // BEGIN Common generator invocation
  override def invoke(form: InvocationForm): Either[Seq[String], Seq[File]] = invoke(form, addHeader = true)

  def invoke(form: InvocationForm, addHeader: Boolean = false): Either[Seq[String], Seq[File]] = generateCode(form, addHeader)

  private def generateCode(form: InvocationForm, addHeader: Boolean = true): Either[Seq[String], Seq[File]] = {
    val header =
      if (addHeader) Some(new ApidocComments(form.service.version, form.userAgent).forClassFile)
      else None
    logger.info(s"Processing Application ${form.service.name}")
    // ENSURE Spec before even creating the generator
    val errors = SpecValidation.validate(form.service, header)
    if (errors.isDefined) {
      return Left(errors.get)
    }
    //Spec passed
    new Generator(form.service, header).generateSourceFiles()
  }

  // END Common generator invocation
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Generates an openapi 3.0.0 file from a specification.
   *
   * @param service the service specification
   * @param header  optional header to add to the top of each generated file
   */
  class Generator(service: Service, header: Option[String]) {
    private val nameSpaces = new NameSpaces(service)

    def generateSourceFiles(): Either[Seq[String], Seq[File]] = {
      Right(generate())
    }

    /**
     * Turns a type into a $ref. Handles external files as long as they are generated by this generator.
     *
     * @param typeIn the type string
     * @return a $ref value
     */
    def toRef(typeIn: String): String = {
      //Handle model names with packages
      if (isModelNameWithPackage(typeIn)) {
        val modelName = JavaPojoUtil.replaceEnumsPrefixWithModels(typeIn)
        val fileName = typeIn.split("\\.").drop(2).dropRight(3).map(_.capitalize).mkString("") + ".yaml"
        return s"${fileName}#/components/schemas/${modelName}"
      }
      //else if (JavaPojoUtil.isModelType(service, typeIn)) {
      //        val modelName = typeIn
      //        val fileName = typeIn.split("\\.").drop(2).dropRight(3).map(_.capitalize).mkString("") + ".yaml"
      //        return s"HELLO${fileName}#/components/schemas/${modelName}"
      //
      //      }
      //handle file local $refs
      s"#/components/schemas/${nameSpaces.model.nameSpace}.${typeIn}"
    }

    val DESCRIPTION = "description"


    def enumToDescription(enum: io.apibuilder.spec.v0.models.Enum): String = {
      var out = Seq[String]()
      if (`enum`.deprecation.isDefined) {
        var depreciaion = `enum`.deprecation.get
        if (depreciaion.description.isDefined) {
          out = out ++ Seq(s"@Depreciated ${depreciaion.description.get}")
        } else {
          out = out ++ Seq("@Depreciated")
        }
      }
      if (`enum`.description.isDefined) {
        out = out ++ Seq(`enum`.description.get)
      }


      out = out ++ Seq("<ol>")
      out = out ++ `enum`.values.map(valueIn => {
        valueIn.name -> (
          if (valueIn.description.isDefined) {
            valueIn.description.get
          } else {
            ""
          }
          )
      }).map(t => s"${t._1} ${t._2}").map(s => s"<li>${s}</li>")
      out = out ++ Seq("</ol>")


      out.mkString("<br> ")
    }


    def generate(): Seq[File] = {
      val schemas = service.models.map(
        modelIn => {
          //////////////////////////////////////////////////////////////////////////////////////////////////////////////
          // START OPENAPI SCHEMA
          val schemaOut = Schema.builder().description(modelIn.description.getOrElse(null))

          modelIn.fields.foreach(
            fieldIn => {
              val propertyOut = Property.builder()
              if (fieldIn.description.isDefined) {
                propertyOut
                  .description(fieldIn.description.get)
              }
              if (isModelNameWithPackage(fieldIn.`type`)) {
                propertyOut
                  .oneOf(Ref.builder().ref(fieldIn.`type`).build())
              } else if (isModelType(service, fieldIn)) {
                propertyOut
                  .oneOf(
                    Ref.builder()
                      .ref(toRef(fieldIn.`type`))
                      .build())
              } else if (JavaPojoUtil.isParameterArray(fieldIn)) {
                propertyOut.`type`(Type.array.name())
                val itemType = fieldIn.`type`.toCharArray.drop(1).dropRight(1).mkString("")
                propertyOut.items(Items.builder().ref(toRef(itemType)).build())
              } else {
                propertyOut.`type`(Type.`object`.name())
                if (fieldIn.`type` == "uuid") {
                  propertyOut.format("uuid")
                } else if (fieldIn.`type` == "date-iso8601")
                  propertyOut.`type`("string")
                    .format("date-time")
              }
              schemaOut.property(fieldIn.name, propertyOut.build())
            }
          )
          nameSpaces.model.nameSpace + "." + modelIn.name -> schemaOut.build()
        }
      ).toMap ++ service.enums.map(
        enumIn => {
          val schemaOut = Schema.builder().description(enumToDescription(enumIn))
          schemaOut.`type`(Type.string)
          schemaOut.enums(
            enumIn.values.map(_.name).asJava
          )
          nameSpaces.model.nameSpace + "." + enumIn.name -> schemaOut.build()
        }
      )

      val components = Components.builder().schemas(schemas.asJava)

      //      service.attributes.filter(OpenAPISecuritySchemes.isThisAttribute(_))
      //        .map(OpenAPISecuritySchemes.asThisAttribute(_))
      //        .filter(_.isDefined)
      //        .map(_.get)
      //        .foreach(
      //          attributeIn => {
      //            val operationOut = new mutable.LinkedHashMap[String, Object].asJava
      //            operationOut.put("type", attributeIn.`type`)
      //            components.securityScheme(attributeIn.name, operationOut)
      //          }
      //        )

      def toOperationId(operation: Operation): String = {
        s"${operation.method.toString.toLowerCase()}-${operation.path.replace("/", "-")}"
      }

      def isAnyModelType(typeIn: String): Boolean = {
        (JavaPojoUtil.isModelType(service, typeIn)
          ||
          JavaPojoUtil.isModelNameWithPackage(typeIn)
          )
      }

      val paths = new mutable.LinkedHashMap[String, Object].asJava
      service.resources.foreach(
        resourceIn => {
          resourceIn.operations.foreach(
            operationIn => {
              val pathOut = new mutable.LinkedHashMap[String, Object].asJava
              val operationOut = new mutable.LinkedHashMap[String, Object].asJava
              pathOut.put(operationIn.method.toString.toLowerCase(), operationOut)
              operationOut.put(DESCRIPTION, operationIn.description.getOrElse(null))
              operationOut.put("operationId", toOperationId(operationIn))
              val parameters = new util.LinkedList[Parameter]()
              operationOut.put("parameters", parameters)
              val responsesOut = new mutable.LinkedHashMap[String, Object].asJava
              operationOut.put("responses", responsesOut)

              //Do response codes
              operationIn.responses.foreach(
                responseIn => {
                  val responseOut = mutable.LinkedHashMap[String, Object]().asJava
                  if (responseIn.description.isDefined) {
                    responseOut.put(DESCRIPTION, responseIn.description.get)
                  }
                  if (responseIn.`type` == "unit") {

                  } else if (isAnyModelType(responseIn.`type`)) {
                    val contentOut = new mutable.LinkedHashMap[String, Object].asJava
                    val contentTypeOut = new mutable.LinkedHashMap[String, Object].asJava
                    contentOut.put("application/json", contentTypeOut)
                    val schemaOut = new mutable.LinkedHashMap[String, Object].asJava
                    schemaOut.put("$ref", toRef(responseIn.`type`))
                    contentTypeOut.put("schema", schemaOut)
                    responseOut.put("content", contentOut)
                  }
                  responsesOut.put(responseIn.code.asInstanceOf[ResponseCodeInt].value.toString, responseOut)
                }
              )


              def toParamSchema(typeIn: String): ParamSchema = {
                val paramSchemaOut = ParamSchema.builder()

                def buildRef(): Ref = {
                  Ref.builder()
                    .ref(
                      toRef(typeIn))
                    .build()

                }
                //If Model with package
                if (isModelNameWithPackage(typeIn)) {
                  paramSchemaOut.oneOf(buildRef())
                  //If Model with package
                } else if (isModelType(service, typeIn)) {
                  paramSchemaOut.oneOf(buildRef())
                  logger.info(s"")
                  if (JavaPojoUtil.isParameterArray(typeIn)) {
                    paramSchemaOut.`type`(Type.array.name())

                    val itemType = typeIn.toCharArray.drop(1).dropRight(1).mkString("")
                    paramSchemaOut.items(
                      Items.builder()
                        .ref(toRef(itemType))
                        .build()
                    )

                  }
                } else {
                  paramSchemaOut.`type`(Type.`object`.name())
                  if (typeIn == "uuid") {
                    paramSchemaOut.`type`("string")
                      .format("uuid")
                  } else if (typeIn == "date-iso8601") {
                    paramSchemaOut.`type`("string")
                      .format("date-time")
                  } else if (typeIn == "string") {
                    paramSchemaOut.`type`("string")
                  }
                }


                paramSchemaOut.build()

              }
              ////////////////////////////////////////////////////////////////////////////////////////////////////////
              ////////////////////////////////////////////////////////////////////////////////////////////////////////


              operationIn.parameters.foreach(
                parameterIn => {
                  val parameterOut = Parameter.builder()
                    .name(parameterIn.name)
                  if (parameterIn.deprecation.isDefined) {
                    parameterOut.deprecated(true)
                  }

                  //////////////////////////////////////////////////////////////////////////////////////////////////////
                  //Make sure this converts
                  parameterOut.schema(
                    toParamSchema(parameterIn.`type`)
                  )
                  //////////////////////////////////////////////////////////////////////////////////////////////////////

                  parameters.add(parameterOut.build())
                }
              )
              paths.put(operationIn.path, pathOut)
            }

          )
        }

      )

      val openapi = OpenApi.builder().components(components.build())
        .paths(paths)
      openapi.info(
        Info.builder()
          .contact(Info.Contact.builder().build())
          .license(License.builder().name("").build())
          .termsOfService("foo.com")
          .title(service.name)
          .version(service.version)
          .build()
      )
      val mapper = new ObjectMapper(new YAMLFactory()).disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)


      val name = JavaPojoUtil.toClassName(service.name);
      Seq(
        File(name = s"${name}.yaml", contents = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(openapi.build()))
      )
    }

  }


}
